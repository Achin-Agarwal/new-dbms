these are the sql tables



CREATE TABLE students (

Â  Â  student_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  name VARCHAR2(100),

Â  Â  roll_no VARCHAR2(20) UNIQUE,

Â  Â  room_no VARCHAR2(10),

Â  Â  hostel_name VARCHAR2(50)

);



CREATE TABLE meal_types (

Â  Â  meal_type_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  name VARCHAR2(20) UNIQUE

);



CREATE TABLE mess_menu (

Â  Â  menu_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  meal_date DATE,

Â  Â  meal_type_id NUMBER,

Â  Â  FOREIGN KEY (meal_type_id) REFERENCES meal_types(meal_type_id)

);



CREATE TABLE menu_items (

Â  Â  item_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  menu_id NUMBER,

Â  Â  item_name VARCHAR2(100),

Â  Â  FOREIGN KEY (menu_id) REFERENCES mess_menu(menu_id)

);



CREATE TABLE meals_taken (

Â  Â  meal_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  student_id NUMBER,

Â  Â  meal_date DATE,

Â  Â  meal_type_id NUMBER,

Â  Â  FOREIGN KEY (student_id) REFERENCES students(student_id),

Â  Â  FOREIGN KEY (meal_type_id) REFERENCES meal_types(meal_type_id)

);



CREATE TABLE monthly_bill (

Â  Â  bill_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  student_id NUMBER,

Â  Â  month VARCHAR2(7),

Â  Â  total_meals NUMBER,

Â  Â  cost_per_meal NUMBER(5, 2),

Â  Â  total_amount NUMBER(7, 2),

Â  Â  is_paid CHAR(1) DEFAULT 'N',

Â  Â  FOREIGN KEY (student_id) REFERENCES students(student_id)

);



CREATE TABLE payments (

Â  Â  payment_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  bill_id NUMBER,

Â  Â  payment_date DATE DEFAULT SYSDATE,

Â  Â  amount_paid NUMBER(7, 2),

Â  Â  payment_method VARCHAR2(20),

Â  Â  FOREIGN KEY (bill_id) REFERENCES monthly_bill(bill_id)

);



CREATE TABLE food_feedback (

Â  Â  feedback_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  student_id NUMBER,

Â  Â  meal_date DATE,

Â  Â  meal_type_id NUMBER,

Â  Â  rating NUMBER(1),

Â  Â  feed_text VARCHAR2(500),

Â  Â  FOREIGN KEY (student_id) REFERENCES students(student_id),

Â  Â  FOREIGN KEY (meal_type_id) REFERENCES meal_types(meal_type_id)

);



CREATE TABLE leave_requests (

Â  Â  leave_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  student_id NUMBER,

Â  Â  from_date DATE,

Â  Â  to_date DATE,

Â  Â  reason VARCHAR2(255),

Â  Â  status VARCHAR2(20) DEFAULT 'Pending',

Â  Â  FOREIGN KEY (student_id) REFERENCES students(student_id)

);



CREATE TABLE mess_staff (

Â  Â  staff_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  name VARCHAR2(100),

Â  Â  role VARCHAR2(50),

Â  Â  contact VARCHAR2(20)

);



CREATE TABLE attendance (

Â  Â  attendance_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  staff_id NUMBER,

Â  Â  date_day DATE,

Â  Â  is_present CHAR(1),

Â  Â  FOREIGN KEY (staff_id) REFERENCES mess_staff(staff_id)

);





CREATE TABLE stock_items (

Â  Â  item_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  name VARCHAR2(100),

Â  Â  unit VARCHAR2(20),

Â  Â  quantity_available NUMBER

);



CREATE TABLE stock_usage (

Â  Â  usage_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  item_id NUMBER,

Â  Â  used_on DATE,

Â  Â  quantity_used NUMBER,

Â  Â  FOREIGN KEY (item_id) REFERENCES stock_items(item_id)

);



CREATE TABLE suppliers (

Â  Â  supplier_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  name VARCHAR2(100),

Â  Â  contact VARCHAR2(50),

Â  Â  address VARCHAR2(255)

);



CREATE TABLE stock_orders (

Â  Â  order_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

Â  Â  item_id NUMBER,

Â  Â  supplier_id NUMBER,

Â  Â  order_date DATE,

Â  Â  quantity_ordered NUMBER,

Â  Â  status VARCHAR2(20) DEFAULT 'Pending',

Â  Â  FOREIGN KEY (item_id) REFERENCES stock_items(item_id),

Â  Â  FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id)

);



and these are the backend routes



// studentRoutes



// Get all students

router.get('/', async (req, res) => {

Â  try {

Â  Â  console.log("here")

Â  Â  const connection = await getConnection();

Â  Â  const result = await connection.execute('SELECT * FROM students');

Â  Â  await connection.close();

Â  Â  console.log(result.rows)

Â  Â  res.json(result.rows);

Â  } catch (err) {

Â  Â  console.error(err);

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Get single student by ID

router.get('/:id', async (req, res) => {

Â  try {

Â  Â  const studentId = req.params.id;

Â  Â  const connection = await getConnection();

Â  Â  const result = await connection.execute(

Â  Â  Â  'SELECT * FROM students WHERE student_id = :id',

Â  Â  Â  { id: studentId }

Â  Â  );

Â  Â  await connection.close();

Â  Â  res.json(result.rows[0]);

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Create new student

router.post('/', async (req, res) => {

Â  const { name, roll_no, room_no, hostel_name } = req.body;

Â  console.log(req.body)

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  await connection.execute(

Â  Â  Â  `INSERT INTO students (name, roll_no, room_no, hostel_name)

Â  Â  Â  Â VALUES (:name, :roll_no, :room_no, :hostel_name)`,

Â  Â  Â  { name, roll_no, room_no, hostel_name },

Â  Â  Â  { autoCommit: true }

Â  Â  );

Â  Â  await connection.close();

Â  Â  res.status(201).json({ message: 'Student created' });

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Update student

router.put('/:id', async (req, res) => {

Â  const { name, roll_no, room_no, hostel_name } = req.body;

Â  const studentId = req.params.id;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  await connection.execute(

Â  Â  Â  `UPDATE students

Â  Â  Â  Â SET name = :name, roll_no = :roll_no, room_no = :room_no, hostel_name = :hostel_name

Â  Â  Â  Â WHERE student_id = :id`,

Â  Â  Â  { name, roll_no, room_no, hostel_name, id: studentId },

Â  Â  Â  { autoCommit: true }

Â  Â  );

Â  Â  await connection.close();

Â  Â  res.json({ message: 'Student updated' });

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Delete student

router.delete('/:id', async (req, res) => {

Â  const studentId = req.params.id;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  await connection.execute(

Â  Â  Â  'DELETE FROM students WHERE student_id = :id',

Â  Â  Â  { id: studentId },

Â  Â  Â  { autoCommit: true }

Â  Â  );

Â  Â  await connection.close();

Â  Â  res.json({ message: 'Student deleted' });

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// mealRoutes

// Get all meals taken

router.get('/', async (req, res) => {

Â  Â  try {

Â  Â  Â  const connection = await getConnection();

Â  Â  Â  const result = await connection.execute('SELECT * FROM meals_taken');

Â  Â  Â  await connection.close();

Â  Â  Â  res.json(result.rows);

Â  Â  } catch (err) {

Â  Â  Â  res.status(500).json({ error: err.message });

Â  Â  }

Â  });

Â  

Â  // Check if student took a specific meal on a day

Â  router.get('/:studentId/date/:date/type/:mealType', async (req, res) => {

Â  Â  const { studentId, date, mealType } = req.params;

Â  Â  try {

Â  Â  Â  const connection = await getConnection();

Â  Â  Â  const result = await connection.execute(

Â  Â  Â  Â  `BEGIN

Â  Â  Â  Â  Â  Â :result := has_taken_meal(:student_id, TO_DATE(:meal_date, 'YYYY-MM-DD'), :meal_type);

Â  Â  Â  Â  Â END;`,

Â  Â  Â  Â  {

Â  Â  Â  Â  Â  result: { dir: oracledb.BIND_OUT, type: oracledb.STRING },

Â  Â  Â  Â  Â  student_id: studentId,

Â  Â  Â  Â  Â  meal_date: date,

Â  Â  Â  Â  Â  meal_type: mealType

Â  Â  Â  Â  }

Â  Â  Â  );

Â  Â  Â  await connection.close();

Â  Â  Â  res.json({ taken: result.outBinds.result });

Â  Â  } catch (err) {

Â  Â  Â  res.status(500).json({ error: err.message });

Â  Â  }

Â  });

Â  

Â  // Get meals for a student

Â  router.get('/:studentId', async (req, res) => {

Â  Â  const studentId = req.params.studentId;

Â  Â  try {

Â  Â  Â  const connection = await getConnection();

Â  Â  Â  const result = await connection.execute(

Â  Â  Â  Â  'SELECT * FROM meals_taken WHERE student_id = :id',

Â  Â  Â  Â  { id: studentId }

Â  Â  Â  );

Â  Â  Â  await connection.close();

Â  Â  Â  res.json(result.rows);

Â  Â  } catch (err) {

Â  Â  Â  res.status(500).json({ error: err.message });

Â  Â  }

Â  });

Â  

Â  // Record a new meal

Â  router.post('/', async (req, res) => {

Â  Â  const { student_id, meal_date, meal_type } = req.body;

Â  Â  try {

Â  Â  Â  const connection = await getConnection();

Â  Â  Â  await connection.execute(

Â  Â  Â  Â  `INSERT INTO meals_taken (student_id, meal_date, meal_type)

Â  Â  Â  Â  Â VALUES (:student_id, TO_DATE(:meal_date, 'YYYY-MM-DD'), :meal_type)`,

Â  Â  Â  Â  { student_id, meal_date, meal_type },

Â  Â  Â  Â  { autoCommit: true }

Â  Â  Â  );

Â  Â  Â  await connection.close();

Â  Â  Â  res.status(201).json({ message: 'Meal recorded' });

Â  Â  } catch (err) {

Â  Â  Â  res.status(500).json({ error: err.message });

Â  Â  }

Â  });



Â  //staffRoutes

Â  // Get all staff members

Â  router.get('/', async (req, res) => {

Â  Â  try {

Â  Â  Â  const connection = await getConnection();

Â  Â  Â  const result = await connection.execute('SELECT * FROM staff');

Â  Â  Â  await connection.close();

Â  Â  Â  res.json(result.rows);

Â  Â  } catch (err) {

Â  Â  Â  res.status(500).json({ error: err.message });

Â  Â  }

Â  });

Â  

Â  // Mark attendance (calls PL/SQL proc mark_attendance)

Â  router.post('/attendance', async (req, res) => {

Â  Â  const { staff_id } = req.body;

Â  Â  try {

Â  Â  Â  const connection = await getConnection();

Â  Â  Â  await connection.execute(

Â  Â  Â  Â  `BEGIN

Â  Â  Â  Â  Â  Â mark_attendance(:staff_id);

Â  Â  Â  Â  Â END;`,

Â  Â  Â  Â  { staff_id }

Â  Â  Â  );

Â  Â  Â  await connection.commit();

Â  Â  Â  await connection.close();

Â  Â  Â  res.json({ message: 'Attendance marked.' });

Â  Â  } catch (err) {

Â  Â  Â  res.status(500).json({ error: err.message });

Â  Â  }

Â  });

Â  

Â  // Get attendance by staff ID

Â  router.get('/attendance/:staffId', async (req, res) => {

Â  Â  const { staffId } = req.params;

Â  Â  try {

Â  Â  Â  const connection = await getConnection();

Â  Â  Â  const result = await connection.execute(

Â  Â  Â  Â  'SELECT * FROM attendance WHERE staff_id = :staffId',

Â  Â  Â  Â  { staffId }

Â  Â  Â  );

Â  Â  Â  await connection.close();

Â  Â  Â  res.json(result.rows);

Â  Â  } catch (err) {

Â  Â  Â  res.status(500).json({ error: err.message });

Â  Â  }

Â  });



Â  //menuRoutes



Â  // Get menu for a specific date and type (more specific route first)

Â  router.get('/:date/:type', async (req, res) => {

Â  Â  const { date, type } = req.params;

Â  Â  try {

Â  Â  Â  const connection = await getConnection();

Â  Â  Â  const result = await connection.execute(

Â  Â  Â  Â  `SELECT * FROM menu WHERE menu_date = TO_DATE(:date, 'YYYY-MM-DD') AND meal_type = :type`,

Â  Â  Â  Â  { date, type }

Â  Â  Â  );

Â  Â  Â  await connection.close();

Â  Â  Â  res.json(result.rows);

Â  Â  } catch (err) {

Â  Â  Â  res.status(500).json({ error: err.message });

Â  Â  }

Â  });

Â  

Â  // Get menu for a specific date

Â  router.get('/:date', async (req, res) => {

Â  Â  const { date } = req.params;

Â  Â  try {

Â  Â  Â  const connection = await getConnection();

Â  Â  Â  const result = await connection.execute(

Â  Â  Â  Â  `SELECT * FROM menu WHERE menu_date = TO_DATE(:date, 'YYYY-MM-DD')`,

Â  Â  Â  Â  { date }

Â  Â  Â  );

Â  Â  Â  await connection.close();

Â  Â  Â  res.json(result.rows);

Â  Â  } catch (err) {

Â  Â  Â  res.status(500).json({ error: err.message });

Â  Â  }

Â  });

Â  

Â  // Get all menu entries

Â  router.get('/', async (req, res) => {

Â  Â  try {

Â  Â  Â  const connection = await getConnection();

Â  Â  Â  const result = await connection.execute('SELECT * FROM menu');

Â  Â  Â  await connection.close();

Â  Â  Â  res.json(result.rows);

Â  Â  } catch (err) {

Â  Â  Â  res.status(500).json({ error: err.message });

Â  Â  }

Â  });



// feedbackRoutes



router.post('/', async (req, res) => {

Â  const { student_id, feedback_text } = req.body;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  await connection.execute(

Â  Â  Â  `BEGIN

Â  Â  Â  Â  Â submit_feedback(:student_id, :feedback_text);

Â  Â  Â  Â END;`,

Â  Â  Â  { student_id, feedback_text }

Â  Â  );

Â  Â  await connection.commit();

Â  Â  await connection.close();

Â  Â  res.json({ message: 'Feedback submitted.' });

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Get all feedback

router.get('/', async (req, res) => {

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  const result = await connection.execute('SELECT * FROM feedback');

Â  Â  await connection.close();

Â  Â  res.json(result.rows);

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Get feedback by student

router.get('/:studentId', async (req, res) => {

Â  const { studentId } = req.params;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  const result = await connection.execute(

Â  Â  Â  'SELECT * FROM feedback WHERE student_id = :studentId',

Â  Â  Â  { studentId }

Â  Â  );

Â  Â  await connection.close();

Â  Â  res.json(result.rows);

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



//leaveRoutes

// Submit leave request

router.post("/", async (req, res) => {

Â  const { student_id, start_date, end_date, reason } = req.body;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  await connection.execute(

Â  Â  Â  `INSERT INTO leave_requests (student_id, start_date, end_date, reason, status)

Â  Â  Â  Â  Â VALUES (:student_id, TO_DATE(:start_date, 'YYYY-MM-DD'), TO_DATE(:end_date, 'YYYY-MM-DD'), :reason, 'PENDING')`,

Â  Â  Â  { student_id, start_date, end_date, reason }

Â  Â  );

Â  Â  await connection.commit();

Â  Â  await connection.close();

Â  Â  res.json({ message: "Leave request submitted." });

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Approve leave (calls PL/SQL proc approve_leave)

router.put("/:id/approve", async (req, res) => {

Â  const { id } = req.params;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  await connection.execute(

Â  Â  Â  `BEGIN

Â  Â  Â  Â  Â  Â approve_leave(:id);

Â  Â  Â  Â  Â END;`,

Â  Â  Â  { id }

Â  Â  );

Â  Â  await connection.commit();

Â  Â  await connection.close();

Â  Â  res.json({ message: "Leave approved." });

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Get all leave requests

router.get("/", async (req, res) => {

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  const result = await connection.execute("SELECT * FROM leave_requests");

Â  Â  await connection.close();

Â  Â  res.json(result.rows);

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Get leave requests by student

router.get("/:studentId", async (req, res) => {

Â  const { studentId } = req.params;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  const result = await connection.execute(

Â  Â  Â  "SELECT * FROM leave_requests WHERE student_id = :studentId",

Â  Â  Â  { studentId }

Â  Â  );

Â  Â  await connection.close();

Â  Â  res.json(result.rows);

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



//stockRoutes

// Get all stock items

router.get('/', async (req, res) => {

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  const result = await connection.execute('SELECT * FROM stock');

Â  Â  await connection.close();

Â  Â  res.json(result.rows);

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Get all stock orders

router.get('/orders', async (req, res) => {

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  const result = await connection.execute('SELECT * FROM stock_orders');

Â  Â  await connection.close();

Â  Â  res.json(result.rows);

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Get stock item by ID

router.get('/:id', async (req, res) => {

Â  const { id } = req.params;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  const result = await connection.execute(

Â  Â  Â  'SELECT * FROM stock WHERE stock_id = :id',

Â  Â  Â  { id }

Â  Â  );

Â  Â  await connection.close();

Â  Â  res.json(result.rows[0]);

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Use stock (call PL/SQL proc use_stock)

router.post('/usage', async (req, res) => {

Â  const { stock_id, quantity } = req.body;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  await connection.execute(

Â  Â  Â  `BEGIN

Â  Â  Â  Â  Â use_stock(:stock_id, :quantity);

Â  Â  Â  Â END;`,

Â  Â  Â  { stock_id, quantity }

Â  Â  );

Â  Â  await connection.commit();

Â  Â  await connection.close();

Â  Â  res.json({ message: 'Stock usage recorded.' });

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Create a stock order (call PL/SQL proc create_stock_order)

router.post('/order', async (req, res) => {

Â  const { stock_id, supplier_id, quantity } = req.body;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  await connection.execute(

Â  Â  Â  `BEGIN

Â  Â  Â  Â  Â create_stock_order(:stock_id, :supplier_id, :quantity);

Â  Â  Â  Â END;`,

Â  Â  Â  { stock_id, supplier_id, quantity }

Â  Â  );

Â  Â  await connection.commit();

Â  Â  await connection.close();

Â  Â  res.json({ message: 'Stock order placed.' });

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



//billingRoutes

// Generate monthly bill (calls PL/SQL proc calculate_monthly_bill)

router.post('/generate', async (req, res) => {

Â  const { student_id, bill_month } = req.body;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  await connection.execute(

Â  Â  Â  `BEGIN

Â  Â  Â  Â  Â calculate_monthly_bill(:student_id, TO_DATE(:bill_month, 'YYYY-MM'));

Â  Â  Â  Â END;`,

Â  Â  Â  { student_id, bill_month }

Â  Â  );

Â  Â  await connection.commit();

Â  Â  await connection.close();

Â  Â  res.json({ message: 'Bill generated.' });

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Get bills for a student

router.get('/:studentId', async (req, res) => {

Â  const { studentId } = req.params;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  const result = await connection.execute(

Â  Â  Â  'SELECT * FROM billing WHERE student_id = :studentId',

Â  Â  Â  { studentId } // <-- FIXED

Â  Â  );

Â  Â  await connection.close();

Â  Â  res.json(result.rows);

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Get unpaid balance (calls PL/SQL func get_student_balance)

router.get('/balance/:studentId', async (req, res) => {

Â  const { studentId } = req.params;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  const result = await connection.execute(

Â  Â  Â  'SELECT get_student_balance(:studentId) AS balance FROM dual',

Â  Â  Â  { studentId } // <-- FIXED

Â  Â  );

Â  Â  await connection.close();

Â  Â  res.json(result.rows[0]);

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



// Pay bill (calls PL/SQL proc pay_bill)

router.post('/pay', async (req, res) => {

Â  const { bill_id, amount } = req.body;

Â  try {

Â  Â  const connection = await getConnection();

Â  Â  await connection.execute(

Â  Â  Â  `BEGIN

Â  Â  Â  Â  Â pay_bill(:bill_id, :amount);

Â  Â  Â  Â END;`,

Â  Â  Â  { bill_id, amount }

Â  Â  );

Â  Â  await connection.commit();

Â  Â  await connection.close();

Â  Â  res.json({ message: 'Payment successful.' });

Â  } catch (err) {

Â  Â  res.status(500).json({ error: err.message });

Â  }

});



this is my react folder file structure





```

â””â”€â”€ ğŸ“frontend

Â  Â  â””â”€â”€ ğŸ“public

Â  Â  Â  Â  â””â”€â”€ vite.svg

Â  Â  â””â”€â”€ ğŸ“src

Â  Â  Â  Â  â””â”€â”€ App.css

Â  Â  Â  Â  â””â”€â”€ App.jsx

Â  Â  Â  Â  â””â”€â”€ ğŸ“assets

Â  Â  Â  Â  Â  Â  â””â”€â”€ react.svg

Â  Â  Â  Â  â””â”€â”€ ğŸ“components

Â  Â  Â  Â  â””â”€â”€ index.css

Â  Â  Â  Â  â””â”€â”€ ğŸ“layouts

Â  Â  Â  Â  Â  Â  â””â”€â”€ Layout.jsx

Â  Â  Â  Â  â””â”€â”€ main.jsx

Â  Â  Â  Â  â””â”€â”€ ğŸ“pages

Â  Â  Â  Â  Â  Â  â””â”€â”€ Attendance.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ Billing.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ Dashboard.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ Feedback.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ LeaveRequests.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ Login.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ Meals.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ Menu.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ Orders.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ Profile.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ Stock.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ Students.jsx

Â  Â  Â  Â  Â  Â  â””â”€â”€ Suppliers.jsx

Â  Â  Â  Â  â””â”€â”€ ğŸ“routes

Â  Â  Â  Â  Â  Â  â””â”€â”€ AppRoutes.jsx

Â  Â  Â  Â  â””â”€â”€ ğŸ“services

Â  Â  Â  Â  â””â”€â”€ ğŸ“utils

Â  Â  â””â”€â”€ .gitignore

Â  Â  â””â”€â”€ eslint.config.js

Â  Â  â””â”€â”€ index.html

Â  Â  â””â”€â”€ package-lock.json

Â  Â  â””â”€â”€ package.json

Â  Â  â””â”€â”€ README.md

Â  Â  â””â”€â”€ vite.config.js

```



